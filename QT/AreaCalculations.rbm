

# #  module for shared methods
module ACM
###############################################################
# # get a string layer, returns a layer index
###############################################################     
    def source_to_index(layer_source, aLayer)
        active_sel_layer = $active_layout.begin_layers
        for i in 0..aLayer.length-1      
            if aLayer[i] == layer_source
                break
            end
            active_sel_layer.next
        end
        active_sel_layer.current.layer_index
    end
###############################################################
# # Load the Layer Information into arrays
###############################################################     		
    def reload(aLayerName, aLayer, aLayerIndex)
	#Class LayerProperties
        activeLayer = RBA::LayoutView::current.begin_layers
        row = 0
             
        until  activeLayer.at_end? do   
            current_name = activeLayer.current.name
			# # remove the source information
            for i in 0..current_name.length      
                if activeLayer.current.source[0] === current_name[i]
                    break
                end
            end
		# # remove everything after @           
            for k in 0..activeLayer.current.source.to_s.length    
                if activeLayer.current.source[k] === "@"
                    break
                end
            end  
            aLayerName[row] = current_name[0..(i-1)]
            aLayer[row] = activeLayer.current.source[0..(k-1)] 
            aLayerIndex[row] = activeLayer.current.layer_index
            activeLayer.next
            row += 1
        end 
    end
###############################################################
###############################################################     
end
###############################################################
############################################################### 
#   Main Module includes the interface informations
###############################################################
###############################################################   
module AREAMODULE

    include RBA

    # # derivative class to use the virtual  implemented methods
    class ProgressBar < QProgressBar
        def initialize(parent = nil)end
        def text 
            return ""
        end
        def sizeHint
            return RBA::QSize.new(100, 10)
        end
    end
    class TabWidget < QTabWidget
        def initialize(parent = nil)end 
    end
    class ComboBox < QComboBox
        def initialize(parent = nil)end 
     end
    class TextEdit < QTextEdit 
        def initialize(parent = nil) end 
    end
    class GridLayout < QGridLayout
        def initialize(parent = nil)end
        def addItem ( arg1) super end 
     end
    class ListWidget < QListWidget 
        def initialize(parent = nil) super end
    end 
###############################################################
############################################################### 
#   Main Class , aggregation of classes for the area calculations
###############################################################
###############################################################    
    class AreaCal < QDialog
        include RBA

        def initialize(parent = nil)
            super
			
			$active_layout = RBA::LayoutView::current 
			$mw = RBA::Application.instance.main_window
			$topcell = RBA::CellView::active.layout.top_cell
			$file_path = (RBA::CellView::active.filename)
			$lv = $mw.current_view
			
            @title = ($mw.current_view.title).split("gds")[0]
    
            setWindowTitle("Area Calculations " + @title)
            resize(800, 600)
            setWindowFlags(Qt::Window | Qt::WindowMinimizeButtonHint | Qt::WindowCloseButtonHint);
            setSizeGripEnabled(false)
            # fixed size, min and max is same
            setMinimumSize(850, 650)
            setMaximumSize(850, 650)
			label_version_info = QLabel.new(self)
            label_version_info.text = "Area Calculations V0.1"
			
            #create calcualtion objects  
            @layer_density = LayerDensity.new(self)
            @single_via =  SingleVia.new(self)
            @antenna_ratio =  AntennaRatio.new(self)
            @overlap =  Overlap.new(self)
            @simple_drc = SimpleDRC.new(self)
            
            layout = GridLayout.new(self)
            single_via_grid = GridLayout.new(self)
            layer_density_grid = GridLayout.new(self)
            layer_area_grid = GridLayout.new(self)
            antenna_ratio_grid = GridLayout.new(self)
            overlap_grid = GridLayout.new(self)
            simple_drc_grid = GridLayout.new(self)
            
            setLayout(layout)
            
            #create the taps and insert the tap object
            @tabWidget = TabWidget.new(self)
            @tabWidget.maximumSize = QSize.new(800, 600)
            @tabWidget.minimumSize = QSize.new(800, 600)
            #create the tap object
            single_via_tab = RBA::QDialog::new(self)
            single_via_tab.setLayout(single_via_grid)
            layer_density_tab = RBA::QDialog::new(self)
            layer_density_tab.setLayout(layer_density_grid)
            antenna_ratio_tab = RBA::QDialog::new(self)
            antenna_ratio_tab.setLayout(antenna_ratio_grid)
            overlap_ratio_tab = RBA::QDialog::new(self)
            overlap_ratio_tab.setLayout(overlap_grid)
            simple_drc_tab = RBA::QDialog::new(self)
            simple_drc_tab.setLayout(simple_drc_grid)
            
            layout.addWidget(@tabWidget, 0, 0, 1, 2)
			layout.addWidget(label_version_info, 1, 0, 1, 1)
            #place the applications on the layout
            layer_density_grid.addWidget(@layer_density, 0, 0, 1, 1)
            single_via_grid.addWidget(@single_via, 0, 0, 2, 2)
            antenna_ratio_grid.addWidget(@antenna_ratio, 0, 0, 2, 2)    
            overlap_grid.addWidget(@overlap, 0, 0, 2, 2) 
            simple_drc_grid.addWidget(@simple_drc, 0, 0, 2, 2)       
            #antenna_ratio_grid.addItem(RBA::QSpacerItem::new(10,10,QSizePolicy::Minimum,QSizePolicy::Minimum))
            
            @tabWidget.insertTab(1, layer_density_tab, "Layer Area/Density")
            @tabWidget.insertTab(2, single_via_tab, "SingleVia")
            @tabWidget.insertTab(3, antenna_ratio_tab, "Antenna Ratio")
            @tabWidget.insertTab(4, overlap_ratio_tab, "Overlap")
            @tabWidget.insertTab(5, simple_drc_tab, "Simple DRC")
                        
            @tabWidget.setCurrentIndex(4)            
            @tabWidget.setCurrentIndex(3)
            @tabWidget.setCurrentIndex(2)
            @tabWidget.setCurrentIndex(1)
            @tabWidget.setCurrentIndex(0)

        end
    end    

###############################################################
############################################################### 
# # Calculates the Single Vias out of total vias  
###############################################################
###############################################################    
    class SingleVia < QDialog
        include RBA
        include ACM
        def initialize(parent = nil, f = Qt::Window | Qt::WindowMinimizeButtonHint | Qt::WindowCloseButtonHint )
            super  
            setMinimumSize(800, 550)
            setMaximumSize(800, 550)
            @active_layout = $active_layout
            @mw = $mw
            @topcell = $topcell
            @file_path = $file_path
            @lv = $mw.current_view
            @title = (@mw.current_view.title).split("gds")[0]
            
            layout = GridLayout.new(self)           

            setLayout(layout)
            @aLayerName = Array.new
            @aLayer = Array.new
            @aLayerIndex = Array.new
            reload(@aLayerName, @aLayer, @aLayerIndex)
            #create the interace widgets		
            combo_via = ComboBox.new(self)
            combo_via.minimumSize = QSize.new(100, 20)
            label_combo_via = QLabel.new(self)
            label_combo_via.text = "Via Layer"
            
            combo_metal = ComboBox.new(self)
            combo_metal.minimumSize = QSize.new(100, 20)
            label_combo_metal = QLabel.new(self)
            label_combo_metal.text = "Metal Layer 1"
            
            combo_metal2 = ComboBox.new(self)
            combo_metal2.minimumSize = QSize.new(100, 20)
            label_combo_metal2 = QLabel.new(self)
            label_combo_metal2.text = "Metal Layer 2"
    
            @textInput = TextEdit.new(self)
            @textInput.minimumSize = QSize.new(100, 180)
            
            @progress = ProgressBar.new(self)
            @progress.setRange(0,100)
            @progress.minimumSize = QSize.new(50, 20)
            @progress.setVisible(true)
            @progress.setTextVisible(false)
            @progress.value = 0
            
            placeholder = QLabel.new(self)
            placeholder.minimumSize = QSize.new(400, 180)
            placeholder.text= <<LABEL;
<html>
<body>
<h2>necessary steps for a calculation:</h2><p>
<ol>
    <li><b>choose Via Layer</b></li>
    <li><b>choose Metal Layer 1</b></li>
    <li><b>choose Metal Layer 2</b></li>
    <li><b>press Calculate SingleVia slow or fast</b></li>
</ol>
When using fast Calculation: <br>
If bad allocation error occurs, restart KLayout and use slow calculation</b> <br>
<p>

</body></html>
            
LABEL
#/
            # add the widgets to the layout
            layout.addWidget(placeholder, 6, 1, 1, 1)
            layout.addWidget(label_combo_via, 0, 0, 1, 1)
            layout.addWidget(combo_via, 1, 0, 1, 1)
            layout.addWidget(label_combo_metal, 2, 0, 1, 1)
            layout.addWidget(combo_metal, 3, 0, 1, 1)
            layout.addWidget(label_combo_metal2, 4, 0, 1, 1)
            layout.addWidget(combo_metal2, 5, 0, 1, 1)
            layout.addWidget(@textInput, 6, 0, 2, 1)
         
            b1 = QPushButton.new(self)
            b1.text = "Calculate SingleVia \n fast but memory intensive"
            b1.minimumSize = QSize.new(50, 50)
            b1.clicked do
                calculation_settings(combo_via.currentText,combo_metal.currentText,combo_metal2.currentText, true)
            end
            layout.addWidget(b1, 8, 0, 1, 1)
                        
            b2 = QPushButton.new(self)
            b2.text = "Calculate SingleVia\n slower but less memory intensive"
            b2.minimumSize = QSize.new(50, 50)
            b2.clicked do
                calculation_settings(combo_via.currentText,combo_metal.currentText,combo_metal2.currentText, false)
            end
            layout.addWidget(b2, 10, 0, 1, 1)
            layout.addWidget(@progress, 12, 0, 1, 1)
			
            combo_via.addItems(@aLayer)
            combo_metal.addItems(@aLayer)
            combo_metal2.addItems(@aLayer)
        end         
###############################################################
# # Settings for the SingleVia calculation
###############################################################          
        def calculation_settings(via_layer, metal_layer,metal_layer2, fast_cal)
            time_start = Time.now
            @singlevia_polygon = Array.new
            @singlevia_coordinates = Array.new
            values = Array.new
            values = singlevia_calculation(via_layer, metal_layer,metal_layer2 , fast_cal,@singlevia_polygon,@singlevia_coordinates)
            singlevia_count = @singlevia_polygon.length
            data_path = @file_path + @title + "_" + "ViaDensity.csv"
            report = "Total Via count:"+ values[0].to_s + "\n"+  "Single Via count:" + singlevia_count.to_s + "\n" 
            report = report + "Multiple Via count:" + (values[0]-singlevia_count).to_s + "\n" + "Calculation Time:" + ( Time.now-time_start).to_s + " seconds" 
            report = report + "\n data saved under " + data_path
            @textInput.setPlainText(report)
            @textInput.repaint
            data_to_file(@singlevia_polygon,@singlevia_coordinates,report, data_path) 
        end   
###############################################################
# # data storage into a file
###############################################################           
        def data_to_file(singlevia_polygon, singlevia_coordinates, report, data_path)
            dbu = @mw.current_view.active_cellview.layout.dbu
            if !@file_path == nil  then raise "No File path" end
            File.open(data_path, "a") do |file|      
                file.puts( "\n \n" + Time.now.to_s + "\n \n" + report + "\n \n")
                singlevia_coordinates.each do |point|
                    value = (point.x*dbu).to_s + ";"+  (point.y*dbu).to_s
                    file.puts(value)
                end
            end   
        end
###############################################################
# # main process for the SingleVia calculation
###############################################################              
        def singlevia_calculation(via_layer, metal_layer,metal_layer2 , fast_cal, singlevia_polygon,singlevia_coordinates)
            if !@lv || !@lv.active_cellview
                raise "Multiclip: No view or no layout active"
            end
            lv = @mw.current_view
            dbu = @mw.current_view.active_cellview.layout.dbu
            lay = lv.active_cellview.layout
            #lay.flatten( @topcell.cell_index, -1,true)
            topcell  =  @topcell   
            cv = @mw.current_view.active_cellview
            singlevia_coordinates.push(@topcell.bbox.p1)
            singlevia_coordinates.push(@topcell.bbox.p2)
            # creates a tiling process which will devide the layout into tiles for calculation to save memory
            metal_overlap = RBA::Region::new()       
            tp = RBA::TilingProcessor::new
            tp.threads = 4
            tp.input("a1",RBA::Region::new(topcell.begin_shapes_rec(source_to_index(metal_layer, @aLayer))))
            tp.input("a2",RBA::Region::new(topcell.begin_shapes_rec(source_to_index(metal_layer2, @aLayer))))
            tp.output("x1", metal_overlap)
            tp.tile_size(50, 50)
            tp.queue("_output(x1, a1 & a2)")
            tp.execute("1")
            tp._destroy

            via_region = RBA::Region::new()   
            iter_vial = (@topcell.begin_shapes_rec(source_to_index(via_layer, @aLayer)))
            via_total = 0

            metal_overlap.merge

            if fast_cal
                while !iter_vial.at_end?
                    if !iter_vial.shape.is_path? && !iter_vial.shape.is_text? && !iter_vial.shape.is_polygon?
                        via_region.insert(iter_vial.shape.polygon)
                    end
                    via_total += 1
                    iter_vial.next
                end
                metal_merged_over_via = (metal_overlap.select_interacting(via_region)).dup
                metal_overlap._destroy
            else
            # slow calculation, only count via's
                while !iter_vial.at_end?
                    via_total += 1
                    iter_vial.next
                end
                metal_merged_over_via = metal_overlap
            end
            # destroy the unnecessary objects after calculation, save memory
            via_region._destroy
            shape_interconnect = 0
            metal_merged_over_via.each do
                shape_interconnect += 1
            end
            
            time_start = Time.now
            max_via_shape = 0
            shape_counter = 0 
            @progress.value = 0
            # iterate over every single merge metal shape
            metal_merged_over_via.each do |polygon|
            # select all overlapping via's
                via_over_metal = RBA::Region::new(topcell.begin_shapes_rec_overlapping(source_to_index(via_layer, @aLayer), polygon.bbox))	
                count_via = 0 
                via_over_metal.each do
                    count_via += 1
                end
                if count_via == 1
                    @textInput.repaint
                    via_over_metal.each do |polygon|
                        singlevia_polygon.push(polygon)
                        singlevia_coordinates.push(polygon.bbox.center)
                    end     
                elsif  count_via >  max_via_shape
                    max_via_shape = count_via       
                end                 
                shape_counter += 1
                @progress.value = (shape_counter*100)/shape_interconnect
                via_over_metal._destroy
                
                estimated_time = "\n estimated remaining time " + ((((Time.now-time_start) /shape_counter)*(shape_interconnect-shape_counter)).round(2)).to_s + " in seconds"
                @textInput.setPlainText("Calculate Gate " + shape_counter.to_s + " out of " +  shape_interconnect.to_s + estimated_time)
            end          
            single_via_region = RBA::Region::new(singlevia_polygon)
            # show the single via's in layer 400
            helpl = cv.layout.layer(RBA::LayerInfo::new(400,0))
            @topcell.layout.clear_layer(helpl)
            @topcell.shapes( helpl).insert(single_via_region)  

            metal_merged_over_via._destroy
            value = [via_total, max_via_shape]
        end
###############################################################
# # calculate singlevia's on a big metal plate
###############################################################              
        def via_on_metal(via_layer, metal_layer, xw = 50, yw = 50)
            via_data = Array.new 
            metal_data = Array.new
            (nrows,ncolumns) =  density_calculation(via_layer, via_data)
            (nrows,ncolumns) =  density_calculation(metal_layer, metal_data)
            i = 0
            via_data.each do |data|
                if data
                   metal_data[i] =  metal_data[i]/data
                else   
                    metal_data[i] =  data
                end
                i += 1
            end   
             save_values(via_layer, metal_data, nrows, ncolumns)
        end
###############################################################
###############################################################          
    end        
###############################################################
###############################################################  
# # Calculates the layer density and area
###############################################################
###############################################################   
    class LayerDensity < QDialog
        include RBA   
        include ACM
        def initialize(parent = nil)
            super
            setMinimumSize(750, 550)
            setMaximumSize(750, 550)
            @active_layout = $active_layout
            @mw = $mw
            @topcell = $topcell
            @file_path = $file_path
            @lv = $mw.current_view
            
            @title = ($mw.current_view.title).split("gds")[0]
            @aLayerName = Array.new
            @aLayer = Array.new
            @aLayerIndex = Array.new
            reload(@aLayerName, @aLayer, @aLayerIndex)
            
            layout = GridLayout.new(self)
            combogrid = GridLayout.new(self)
            spinboxgrid = GridLayout.new(self)
            setLayout(layout)
            # create the interface widgets
            @tree_source = ListWidget.new(self)            
            @tree_source.minimumSize = QSize.new(50, 250)
            @tree_source.setSelectionMode( QAbstractItemView::ExtendedSelection)
            @tree_source.sortItems(Qt::AscendingOrder)
            @tree_source.doubleClicked do 
                @tree_source.selectedItems.each do |item|
                    @tree_density_layer.addItem(item.text)
                    item.destroy
                end
            end
            @tree_density_layer = ListWidget.new(self)
            @tree_density_layer.minimumSize = QSize.new(50, 250)
            @tree_density_layer.setSelectionMode( QAbstractItemView::ExtendedSelection)
            @tree_density_layer.sortItems(Qt::AscendingOrder)
            @tree_density_layer.doubleClicked do 
                @tree_density_layer.selectedItems.each do |item|
                    @tree_source.addItem(item.text)
                    item.destroy
                end
            end
            combo_ref = ComboBox.new(self)
            label_combo_ref = QLabel.new(self)
            label_combo_ref.text = "Geometry Reference Layer"
            
            spinbox_resolution_x = QDoubleSpinBox.new(self)   
            spinbox_resolution_x.minimumSize = QSize.new(50, 20)
            spinbox_resolution_x.value = 50
            
            label_res_x = QLabel.new(self)           
            label_res_x.text = "Density Resolution X"
            
            spinbox_resolution_y = QDoubleSpinBox.new(self)               
            spinbox_resolution_y.minimumSize = QSize.new(50, 20)
            spinbox_resolution_y.value = 50
            
            label_res_y = QLabel.new(self)
            label_res_y.text = "Density Resolution Y"
            
            @textInput = TextEdit.new(self)
            @textInput.minimumSize = QSize.new(100,150)
            
            layout.addWidget(@tree_source, 0, 0, 4, 1)
            layout.addWidget(@tree_density_layer, 0, 2, 4, 1)

            layout.addLayout(combogrid, 5, 0, 2, 1)
            combogrid.addWidget(label_combo_ref, 0, 0, 1, 1)
            combogrid.addWidget(combo_ref, 1,0, 1, 1)
     
            layout.addLayout(spinboxgrid, 4, 2, 3, 1)
            spinboxgrid.addWidget(label_res_x, 0, 1, 1, 1)
            spinboxgrid.addWidget(spinbox_resolution_x, 1, 1, 1, 1)
            spinboxgrid.addWidget(label_res_y, 2, 1, 1, 1)
            spinboxgrid.addWidget(spinbox_resolution_y, 3, 1, 1, 1)
            spinboxgrid.addWidget(@textInput, 4, 1, 1, 1)
             
            @tree_source.addItems(@aLayer)
            combo_ref.addItems(@aLayer)
                        
            b1 = QPushButton.new(self)
            b1.text = "->"
            b1.minimumSize = QSize.new(50, 50)
            b1.clicked do
                @tree_source.selectedItems.each do |item|
                    @tree_density_layer.addItem(item.text)
                    item.destroy
                end
            end
            layout.addWidget(b1, 1, 1, 1, 1)
	    
            b2 = QPushButton.new(self)
            b2.text = "<-"
            b2.minimumSize = QSize.new(50, 50)
            b2.clicked do
                @tree_density_layer.selectedItems.each do |item|
                    @tree_source.addItem(item.text)
                    item.destroy 
                end
            end
            layout.addWidget(b2, 2, 1, 1, 1)
	    
            b3 = QPushButton.new(self)
            b3.text = "Calculate\nLayer Density"
            b3.minimumSize = QSize.new(20, 50)
            b3.clicked do
                @textInput.setPlainText("Start Layer Density Calculation")
                @tree_density_layer.selectAll
                report =  "data saved under: \n"
                @tree_density_layer.selectedItems.each do |item|
                    data_path = density_calculation(item.text,spinbox_resolution_x.value,spinbox_resolution_y.value)
                    report = report + data_path + "\n"
                end
                @textInput.setPlainText(report)
            end
            combogrid.addWidget(b3, 2, 0, 1, 1)
	    
            b4 = QPushButton.new(self)
            b4.text = "Calculate\nLayer Area"
            b4.minimumSize = QSize.new(20, 50)
            b4.clicked do
                @textInput.setPlainText("Start Layer Area Calculation")
                @textInput.repaint
                @tree_density_layer.selectAll
                output = "Area in % ; Area in mu^2 ; Layer ; " + (Time.now).to_s + "\n"
                @tree_density_layer.selectedItems.each do |item|
                    output = output + area_calculation(item.text,combo_ref.currentText) + "\n"
                end
                data_path = @file_path + @title +  "_Area.csv"
                @textInput.setPlainText(output +"\n\nsaved under: " + data_path)
                File.open(data_path, "a") do |file|
                    file.puts(output)
                end
            end
            combogrid.addWidget(b4, 3, 0, 1, 1)   
	    
            b5 = QPushButton.new(self)
            b5.text = "Refresh\nLayer List"
            b5.minimumSize = QSize.new(20, 50)
            b5.clicked do
                reload_trees
            end
            combogrid.addWidget(b5, 4, 0, 1, 1)
        end
###############################################################
# # Calculates the chip area as reference
###############################################################     
        def chip_area(sel_layer,dbu)
            cv = @mw.current_view.active_cellview
            a = 0
            region = RBA::Region::new(@topcell.begin_shapes_rec(source_to_index(sel_layer, @aLayer)))
            region.merge
            @xmin =  region.bbox.p1.x*dbu
            @ymin = region.bbox.p1.y*dbu
            @xmax = region.bbox.p2.x*dbu
            @ymax = region.bbox.p2.y*dbu
            @xw = 50     # horizontal window size
            @yw = 50        # vertical window size
            a =  region.bbox.area
            a*dbu*dbu 
        end
###############################################################
# # Refresh the layer list widgets, new input by KLayout
###############################################################    
        def reload_trees
            reload(@aLayerName, @aLayer, @aLayerIndex)
            @tree_density_layer.clear
            @tree_source.clear
            @tree_source.addItems(@aLayer)  
        end
###############################################################
# # Settings for the density calculation
###############################################################           
        def density_calculation(sel_layer, xw = 50, yw = 50)
            chip = @topcell.bbox
            dbu = @lv.active_cellview.layout.dbu
            @xmin =  chip.p1.x*dbu
            @ymin = chip.p1.y*dbu
            @xmax = chip.p2.x*dbu
            @ymax = chip.p2.y*dbu
            @xw = xw     # horizontal window size
            @yw = yw        # vertical window size
            data = []
            values = layer_calc(sel_layer, data)
            save_density_map(sel_layer, values[0],values[1],data)  
        end
###############################################################
# # Settings for the area calculation
###############################################################          
        def area_calculation(sel_layer, ref_layer)
            dbu = @lv.active_cellview.layout.dbu
            chip = chip_area(sel_layer,dbu)
            values = layer_calc(sel_layer)
            a = values[2]
            
            active_sel_layer = @active_layout.begin_layers
            for i in 0..@aLayer.length-1      
                if @aLayer[i] == sel_layer
                    break
                end
                active_sel_layer.next
            end
            output = sprintf("%.2f ; ",(a )/chip*100)
            output += sprintf("%.2f ; ", a)
            output += ((active_sel_layer.current.source(true).split("@")[0])).to_s + " ; "
        end
###############################################################
# # Calculate layer density and the layer area
###############################################################      
        def layer_calc(sel_layer, data = []) 
            if !@lv || !@lv.active_cellview
                raise "Multiclip: No view or no layout active"
            end
            if !sel_layer 
                raise "Multiclip: No layer selected"
            end
            x = 0
            data_area = 0
            # obtain the pointers to the layout and cell 
            lay = @lv.active_cellview.layout
            top = @lv.active_cellview.cell_index
            top_name = lay.cell_name(top)
            top_bbox = lay.cell(top).bbox
            dbu = lay.dbu
            
            # identify the layer to take the density from
            input_layer = source_to_index(sel_layer, @aLayer)

			# Start to collect the data:
			# proceed row by row
			# (for each row we use the multi_clip_into which is more efficient than single clips per window)
            nrows = 0
            y = @ymin
            while y < @ymax-1e-6

			# Prepare a new layout to receive the clips
			# Hint: we need to clip all layers (clip does not support clipping of one layer alone currently).
                cl = RBA::Layout.new
                cl.dbu = dbu
                lay.layer_indices.each do |li|
                    cl.insert_layer_at(li, lay.get_info(li))
                end

                # Prepare the clip boxes for this row.
                # Note: because clip only works with boxes that overlap the cell's bounding box currently, we
                # have to operate with a subset of fields to support the general case.
                boxes = []
                x = @xmin
                ncolumns = 0
                colstart = nil
                while x < @xmax-1e-6
                    b = RBA::Box.new((0.5 + x / dbu).floor, (0.5 + y / dbu).floor, (0.5 + (x + @xw) / dbu).floor, (0.5 + (y + @yw) / dbu).floor);
                    if b.overlaps?(top_bbox)
                        colstart ||= ncolumns 
                        boxes.push(b)
                    end
                    x += @xw
                    ncolumns += 1
                end
                columns = []
                ncolumns.times { columns.push(0.0)}

                if colstart
                    col = colstart
    			# Actually do the clip
                    cells = lay.multi_clip_into(top, cl, boxes)
                    ep = RBA::ShapeProcessor.new
                    merged = RBA::Shapes.new
						# Compute the area within area box
                    cells.each do |c|
                            # merge the shapes to polygons and compute the area
                        ep.merge(cl, cl.cell(c), input_layer, merged, true, 0, false, false)
                        a = 0
                        merged.each do |m|
                            a += m.polygon.area
                        end
                            # compute and store the density
                        data_area += a * dbu * dbu
                        a = a * dbu * dbu / (@xw *@xw)
                        columns[col] = a
                        col += 1
                    end
                end
                columns.each { |d| data.push(d) }
                y += @yw
                nrows += 1
            end
            values = [nrows,ncolumns,data_area]
        end
###############################################################
# # transform the area values into a image, black and white
###############################################################          
        def save_density_map(sel_layer, nrows, ncolumns,data = [])    
        #save the area density array into a .png image
            active_sel_layer = @active_layout.begin_layers
            for i in 0..@aLayer.length-1      
                if @aLayer[i] == sel_layer
                    break
                end
                active_sel_layer.next
            end
            data_path = @file_path + @title + "_" + active_sel_layer.current.source_layer.to_s + "_" + active_sel_layer.current.source_datatype.to_s + "_DensityMap.csv"
            if nrows * ncolumns > 0
                data_string = ""
                File.open(data_path, "a") do |file|
                    qimg = QImage.new(ncolumns,nrows,RBA::QImage_Format::Format_RGB32)
                    for i in 0..nrows-1
                        for k in 0..ncolumns-1
                            value = data[k+i*ncolumns]
                            data_string  += value.to_s + ";"
                            value = (value*255).floor #value*256
                            qimg.setPixel(k,i,((value*65536)+(value*256)+value))
                        end
                        file.puts(data_string)
                        data_string.clear
                    end
                    qimg = qimg.mirrored(false,true)
                    qimg.save(@file_path + @title + "_" + active_sel_layer.current.source_layer.to_s + "_" + active_sel_layer.current.source_datatype.to_s + ".bmp")
                end
            end
            return data_path		
        end
###############################################################
###############################################################    
    end
###############################################################
###############################################################  
# # Calculates the Antenna effect
###############################################################
###############################################################   
    class AntennaRatio < QDialog
        include RBA
        include ACM
        def initialize(parent = nil)
            super
            setMinimumSize(750, 550)
            setMaximumSize(750, 550)
            @active_layout = $active_layout
            @mw = $mw
            @topcell = $topcell
            @file_path = $file_path
            @lv = $mw.current_view
        
            @title = (@mw.current_view.title).split("gds")[0]
            @aLayerName = Array.new
            @aLayer = Array.new
            @aLayerIndex = Array.new
            dbu = @mw.current_view.active_cellview.layout.dbu
            
            layout = GridLayout.new(self)
            combogrid = GridLayout.new(self)
            setLayout(layout)
            #create layout widgets
            combo_active = ComboBox.new(self)
            combo_active.minimumSize = QSize.new(20, 20)
            label_combo_active = QLabel.new(self)
            label_combo_active.text = "Active Layer"
            
            combo_poly = ComboBox.new(self)
            combo_poly.minimumSize = QSize.new(20, 20)
            label_combo_poly = QLabel.new(self)
            label_combo_poly.text = "Poly Layer"
            
            label_metal_thickness = QLabel.new(self)
            label_metal_thickness.text = "Metal thickness in µm"
            spinbox_metal_thickness = QDoubleSpinBox.new
            spinbox_metal_thickness.minimumSize = QSize.new(20, 20)
            spinbox_metal_thickness.value = 1
            spinbox_metal_thickness.suffix=(" µm")  
            
            label_tree_dest = QLabel.new(self)
            label_tree_dest.text = "Via Metal Layers ascending order"
            
            tree_source = ListWidget.new(self)
            tree_dest = ListWidget.new(self)            
            tree_source.minimumSize = QSize.new(50, 500)
            tree_source.setSelectionMode( QAbstractItemView::ExtendedSelection)
            tree_source.sortItems(Qt::AscendingOrder)
            tree_source.doubleClicked do 
                tree_source.selectedItems.each do |item|
                    tree_dest.addItem(item.text)
                    item.destroy
                end
            end
            tree_dest.minimumSize = QSize.new(50, 500)
            tree_dest.setSelectionMode( QAbstractItemView::ExtendedSelection)
            tree_dest.sortItems(Qt::AscendingOrder)
            tree_dest.doubleClicked do 
                tree_dest.selectedItems.each do |item|
                    tree_source.addItem(item.text)
                    item.destroy
                end
            end
            
            @textInput = TextEdit.new(self)
            @textInput.minimumSize = QSize.new(40, 250)
            
            @progress = ProgressBar.new(self)
            @progress.setRange(0,100)
            @progress.minimumSize = QSize.new(40, 20)
            @progress.setVisible(true)
            @progress.setTextVisible(false)
            @progress.value = 0
            
            b1 = QPushButton.new(self)
            b1.text = "->"
            b1.minimumSize = QSize.new(50, 50)
            b1.clicked do
                tree_source.selectedItems.each do |item|
                    tree_dest.addItem(item.text)
                    item.destroy
                end
            end
            layout.addWidget(b1, 3, 3, 1, 1)
	    
            b2 = QPushButton.new(self)
            b2.text = "<-"
            b2.minimumSize = QSize.new(50, 50)
            b2.clicked do
                tree_dest.selectedItems.each do |item|
                    tree_source.addItem(item.text)
                    item.destroy 
                end
            end
            layout.addWidget(b2, 4, 3, 1, 1)

            b3 = QPushButton.new(self)
            b3.text = "Start Calculation"
            b3.minimumSize = QSize.new(20, 50)
            b3.clicked do
                tree_dest.selectAll
                calculation_settings(combo_active.currentText,combo_poly.currentText, tree_dest.selectedItems, spinbox_metal_thickness.value)
            end
            # add the widgets to the layout
            layout.addWidget(tree_source, 1, 2, 6, 1)
            layout.addWidget(tree_dest, 1, 4, 6, 1)
            layout.addWidget(label_tree_dest, 0, 4, 1, 1)
            
            combogrid.addWidget(label_combo_active, 1, 0, 1, 1)
            combogrid.addWidget(combo_active, 2, 0, 1, 1)
            combogrid.addWidget(label_combo_poly, 3, 0, 1, 1)
            combogrid.addWidget(combo_poly, 4, 0, 1, 1)
            combogrid.addWidget(label_metal_thickness, 5, 0, 1, 1)
            combogrid.addWidget(spinbox_metal_thickness, 6, 0, 1, 1)
            combogrid.addWidget(@textInput, 8, 0, 1, 1)
            combogrid.addWidget(b3,9, 0, 1, 1) 
            combogrid.addWidget(@progress, 10, 0, 1, 1)            
            layout.addLayout(combogrid, 1, 0, 6, 1)
                               
            reload(@aLayerName, @aLayer, @aLayerIndex)
            @aLayer.each do | name|
                combo_active.addItem(name)
            end
            @aLayer.each do | name|
                combo_poly.addItem(name)
            end
            @aLayer.each do | name|
                tree_source.addItem(name)
            end
        end  
###############################################################
# # transform the area values into a image, black and white
###############################################################          
        def calculation_settings(active_layer, poly_layer, metal_layers, metal_thickness)         
            metal_ratio = Array.new
            via_ratio = Array.new 
            gate_size = Array.new 
            gate_position = Array.new
            values = Array.new
            @textInput.setPlainText("Start Calculation")
            @time_start = Time.now
            antenna_calculation(active_layer, poly_layer, metal_layers, metal_thickness,  metal_ratio, via_ratio, gate_size, gate_position)
            for i in 0..(gate_size.length-1)  
                for k in 0..((metal_layers).length/2)-1
                    metal_ratio[k+i] = (((metal_ratio[k+i])*(metal_thickness))/gate_size[i])
                    via_ratio[k+i] = (((via_ratio[k+i]))/gate_size[i])
                end
            end
            data_path = @file_path + @title + "_" + "Antenna_Ratio.txt"
            report = "Calculation Complete in " + (Time.now - @time_start).to_s + " seconds" 
            report = report + "\n data saved under " + data_path
            @textInput.setPlainText(report)   
            data_to_file( metal_ratio, via_ratio, gate_size, gate_position,metal_layers, data_path)     
            @textInput.update   
        end
###############################################################
# # transform the area values into a image, black and white
###############################################################            
        def data_to_file(metal_ratio, via_ratio, gate_size, gate_position,metal_layers, data_path)
            metal_counter = 0
            File.open(data_path, "a") do |file| 
                for i in 0..(gate_size.length-1)
                    report = ""
                    report += "Gate Position; " + gate_position[i].to_s + "; Gate Size; " + gate_size[i].to_s 
                    for k in 0..(metal_layers.length/2)-1
                        report += "; Ratio Metal" + (k+1).to_s+ " ; " + metal_ratio[metal_counter].to_s + " ;  Ratio Via" + (k).to_s+ " ; " + via_ratio[metal_counter].to_s
                        metal_counter += 1
                    end
                    file.puts(report)
                end 
            end
        end
###############################################################
# # transform the area values into a image, black and white
###############################################################              
        def antenna_calculation(active_layer, poly_layer, metal_layers, metal_thickness, metal_ratio, via_ratio, gate_size, gate_position)
        
            lv = @mw.current_view
            dbu = @mw.current_view.active_cellview.layout.dbu
            lay = lv.active_cellview.layout
            topcell  =  @topcell 
            cv = @mw.current_view.active_cellview

            active = RBA::Region::new(topcell.begin_shapes_rec(source_to_index(active_layer, @aLayer)))
            poly = RBA::Region::new(topcell.begin_shapes_rec(source_to_index(poly_layer, @aLayer)))
            poly.merge
            poly_merged_over_active = poly.select_interacting(active)
            interface_update = 0
            shape_counter = 0
            counter = 0           
            
            metals_merged= Array.new
            sp = ShapeProcessor::new
            count  = 0
            for i in 0..(metal_layers.length/2)-1
                metal_merged = RBA::Shapes::new
                sp.merge(topcell.layout, topcell, source_to_index(metal_layers[count+1].text, @aLayer) , metal_merged, true, 0, false, false)
                metals_merged.push(metal_merged)
                count += 2
            end
            poly_merged_over_active.each do
                shape_counter+=1
            end
            
            time_start = Time.now
            ## calculate the antenna ratio for every poly shape          
            poly_merged_over_active.each do |polygon|
                ## get the gate area
            # Select the active area in the area of the poly net
                active_over_polygon = RBA::Region::new(topcell.begin_shapes_rec_overlapping(source_to_index(active_layer, @aLayer), polygon.bbox))
            
              # Determine the total gate are on this net 
                gate_region = RBA::Region::new(polygon) & active_over_polygon
                gate_size.push(gate_region.area*dbu*dbu)
                puts gate_region.area*dbu*dbu
                gate_position.push(gate_region.bbox.center*dbu)
                gate_region._destroy
                count  = 0
                for i in 0..(metal_layers.length/2)-1
                  # Select via inside the gate net by first selecting a subregion through
                  # the gate net bounding box and then doing a boolean AND
                    via_over_polygon = RBA::Region::new(topcell.begin_shapes_rec_overlapping(source_to_index(metal_layers[count].text, @aLayer), polygon.bbox))
                    via_region = RBA::Region::new(polygon) & via_over_polygon
                
                  # Select the metal net interacting with the vias
                    metal_over_polygon = RBA::Region::new 
                    # NOTE: with a Region for metal_merged we can get rid of this loop:
                    (metals_merged[i]).each_overlapping(polygon.bbox) { |p| metal_over_polygon.insert(p.polygon) }
                    metal_region = metal_over_polygon.select_interacting(via_region)
                    metal_perimeter = 0
                    metal_region.each do |pol|
                        metal_perimeter += pol.perimeter
                    end
                    metal_ratio.push(metal_perimeter*dbu)
                    
                    via_ratio.push(via_region.area*dbu*dbu)
                    metal_over_polygon._destroy
                    count += 2
                end

                counter += 1
                estimated_time = "\n estimated remaining time " + ((((Time.now-time_start) /counter)*(shape_counter-counter)).round(2)).to_s + " in seconds"
                puts estimated_time
                @textInput.setPlainText("Calculate Gate " + counter.to_s + " out of " +  shape_counter.to_s + estimated_time)
                
               @progress.value  = (counter*100)/shape_counter
                if @progress.value == interface_update 
                    @progress.update
                    interface_update += 10
                end
            end
            x = 2
        end
###############################################################
###############################################################                              
    end
###############################################################
###############################################################  
# # Calculates the via overlaping metal, in a range from min to max
###############################################################
###############################################################  
    class Overlap < QDialog
        include RBA
        include ACM
        def initialize(parent = nil)
            super
            setMinimumSize(750, 550)
            setMaximumSize(750, 550)
            @active_layout = $active_layout
            @mw = $mw
            @topcell = $topcell
            @file_path = $file_path
            @lv = $mw.current_view
    
            @title = (@mw.current_view.title).split("gds")[0]
            @aLayerName = Array.new
            @aLayer = Array.new
            @aLayerIndex = Array.new
            
            #setWindowTitle("ViaDensity " + @title)
            #setSizeGripEnabled(false)
            #resize(300, 100)
            #setMinimumSize(300,500)
            #setMaximumSize(300, 500)
            #setWindowFlags(Qt::Window | Qt::WindowMinimizeButtonHint | Qt::WindowCloseButtonHint)
            
            layout = GridLayout.new(self)
            setLayout(layout)
            calculate_grid = GridLayout.new(self)
            # create layout widgets
            combo_via = ComboBox.new(self)
            combo_via.minimumSize = QSize.new(100, 20)
            label_combo_via = QLabel.new(self)
            label_combo_via.text = "Via Layer"
            
            combo_metal = ComboBox.new(self)
            combo_metal.minimumSize = QSize.new(100, 20)
            label_combo_metal = QLabel.new(self)
            label_combo_metal.text = "Metal Layer"

            label_metal_overlap = QLabel.new(self)
            label_metal_overlap.text = "Metal Overlap"
            
            label_metal_smaller = QLabel.new(self)
            label_metal_smaller.text = "<="  
            
            label_metal_greater = QLabel.new(self)
            label_metal_greater.text = ">="          
            spinbox_metal_overlap = QDoubleSpinBox.new
            spinbox_metal_overlap.minimumSize = QSize.new(20, 20)
            spinbox_metal_overlap.setDecimals(3)
            spinbox_metal_overlap.maximum=(1000)
            spinbox_metal_overlap.setMinimum(0.0001)
            spinbox_metal_overlap.value = 0.150  
            spinbox_metal_overlap.suffix=(" µm")  
            
            spinbox_metal_overlap_min = QDoubleSpinBox.new(self)
            spinbox_metal_overlap_min.minimumSize = QSize.new(20, 20)
            spinbox_metal_overlap_min.setDecimals(3)
            spinbox_metal_overlap_min.maximum=(1000)
            spinbox_metal_overlap_min.setMinimum(0.0001)
            spinbox_metal_overlap_min.value = 0 
            spinbox_metal_overlap_min.suffix=(" µm")  
           
            @textInput = TextEdit.new(self)
            @textInput.minimumSize = QSize.new(100,330)
            
            placeholder = QLabel.new(self)
            placeholder.minimumSize = QSize.new(400, 330)
            placeholder.text= <<LABEL;
<html>
<body>
<h2>necessary steps for a calculation:</h2><p>
<ol>
    <li><b>choose Via Layer</b></li>
    <li><b>choose Metal Layer</b></li>
    <li><b>choose min and max overlap in µm</b></li>
    <li><b>press Find Metal Overlap</b></li>
</ol>
<br>
If min and max are equal, the calculation will be done for only this value</b> <br>
<p>

</body></html>
            
LABEL
#/
            #add the widgets to the layout
            layout.addWidget(placeholder, 6, 1, 1, 1)
            layout.addWidget(label_combo_via, 0, 0, 1, 1)
            layout.addWidget(combo_via, 1, 0, 1, 1)
            layout.addWidget(label_combo_metal, 2, 0, 1, 1)
            layout.addWidget(combo_metal, 3, 0, 1, 1)

            layout.addWidget(@textInput, 6, 0, 2, 1)

            calculate_grid.addWidget(label_metal_overlap, 0, 0, 1, 1)
            calculate_grid.addWidget(label_metal_smaller, 0, 1, 1, 1)  
            calculate_grid.addWidget(spinbox_metal_overlap, 0, 2, 1, 1)   
            calculate_grid.addWidget(label_metal_greater, 0, 3, 1, 1)  
            calculate_grid.addWidget(spinbox_metal_overlap_min, 0, 4, 1, 1)       
                                 
            layout.addLayout(calculate_grid, 8, 0, 1, 1) 
            
            b1 = QPushButton.new(self)
            b1.text = "Find Metal Overlap"
            b1.minimumSize = QSize.new(30, 50)
            b1.clicked do
                calculation_settings(combo_via.currentText, combo_metal.currentText, spinbox_metal_overlap.value, spinbox_metal_overlap_min.value)
            end
            layout.addWidget(b1, 9, 0, 1, 1)
            
            reload(@aLayerName, @aLayer, @aLayerIndex)
            @aLayer.each do | name|
                combo_via.addItem(name)
            end
            @aLayer.each do | name|
                combo_metal.addItem(name)
            end
        end           
###############################################################
# #  perpare the calculation and store the results
###############################################################          
        def calculation_settings(via_layer, metal_layer, overlap_d, overlap_d_min)   
            time_start = Time.now
            @overlap_polygon = Array.new
            @overlap_coordinates = Array.new
            overlap_calculation(via_layer, metal_layer, overlap_d, overlap_d_min, @overlap_polygon,@overlap_coordinates)
            overlap_count = @overlap_coordinates.length - 2
            data_path = @file_path + @title + "_" + "OverlapViolations.csv"
            report = "Overlapping violations \n " + overlap_count.to_s + " EdgePairs smaller than " +  overlap_d.to_s + " µm " 
            report = report + " greater than " +  overlap_d_min.to_s + " µm \n"            
            report = report + "Via/Contact Layer: " + (via_layer).to_s + " Metal Layer: " + (metal_layer).to_s 
            report = report +  "\n \n Visible in Layer500,  Add other Layer Entries \n \n Calculation time: " +  (Time.now - time_start).to_s 
            report = report +  "\n \n data saved under " + data_path          
            
            @textInput.setPlainText(report)
            @textInput.repaint
            data_to_file(@overlap_polygon, @overlap_coordinates, report,data_path)          
        end     
###############################################################
# # store the data in a file
###############################################################            
        def data_to_file(overlap_polygon, overlap_coordinates, report,data_path)
            dbu = @mw.current_view.active_cellview.layout.dbu
            if !@file_path == nil  then raise "No File path" end
            File.open(data_path, "a") do |file|      
                file.puts( "\n \n" + Time.now.to_s + "\n \n" + report + "\n \n")
                overlap_coordinates.each do |point|
                value = (point.x*dbu).to_s + ";"+  (point.y*dbu).to_s
                    file.puts(value)
                end
            end   
        end
###############################################################
# # calculate the overlapping metal  over a via shape
###############################################################                 
        def overlap_calculation(via_layer, metal_layer, overlap_d, overlap_d_min, overlap_polygon,overlap_coordinates)
            lv = @mw.current_view
            dbu = @mw.current_view.active_cellview.layout.dbu
            lay = lv.active_cellview.layout
            topcell  =  @topcell   
            cv = @mw.current_view.active_cellview
            @textInput.setPlainText("Start Calculation")
            @textInput.repaint
            overlap_d += dbu
            
            if overlap_d <= overlap_d_min
                raise "The lower limit need to be under " + overlap_d.to_s
            end
            
            via_region = RBA::Region::new(topcell.begin_shapes_rec(source_to_index(via_layer, @aLayer)))   
            # select the via's which overlapping a metal shape
            via_overlap = RBA::Region::new()
            tp = RBA::TilingProcessor::new
            tp.threads = 4
            tp.input("a1", via_region.sized((overlap_d/dbu),2))
            tp.input("a2",RBA::Region::new(topcell.begin_shapes_rec(source_to_index(metal_layer, @aLayer))))
            tp.output("x1", via_overlap)
            tp.tile_size(50, 50)
            tp.queue("_output(x1, a1 & a2)")
            tp.execute("1")
            tp._destroy
            
            #create a frame for the via's
            metal_overlap = RBA::Region::new()
            tp = RBA::TilingProcessor::new
            tp.threads = 4
            tp.input("a1", via_region)
            tp.input("a2",via_overlap)
            tp.output("x1", metal_overlap)
            tp.tile_size(50, 50)
            tp.queue("_output(x1, a2 - a1)")
            tp.execute("1")
            tp._destroy
            via_region._destroy
            via_overlap._destroy
            #remove a frame width < min
            if overlap_d_min != 0
                min = ((overlap_d_min/2)/dbu)
                min -= dbu
                metal_overlap.size(-min,-min,2)
                metal_overlap.size(min,min,2)
            end
            
            overlap_violation_edges = metal_overlap.width_check(overlap_d/dbu,false, nil,80,nil,nil)
            metal_overlap._destroy

            @textInput.setPlainText("Calculation finished\nStart Evaluation")
            @textInput.repaint
           
            overlap_polygon.clear
            overlap_coordinates.clear
            
            overlap_coordinates.push(@topcell.bbox.p1)
            overlap_coordinates.push(@topcell.bbox.p2)
            
            overlap_violation_edges.each do |edge_pair|
                overlap_coordinates.push(edge_pair.polygon(0).bbox.center)
            end      
            #create a layer with width violations
            helpl = cv.layout.layer(RBA::LayerInfo::new(500,0))
            @topcell.layout.clear_layer(helpl)
            @topcell.shapes( helpl).insert(overlap_violation_edges.polygons)  
            overlap_violation_edges._destroy
        end
###############################################################
###############################################################
    end
###############################################################
###############################################################  
###############################################################
###############################################################  
    class SimpleDRC < QDialog
        include RBA
        include ACM
        def initialize(parent = nil)
            super
            setMinimumSize(750, 550)
            setMaximumSize(750, 550)
            
            @active_layout = $active_layout
            @mw = $mw
            @topcell = $topcell
            @file_path = $file_path
            @lv = $mw.current_view
    
            @title = (@mw.current_view.title).split("gds")[0]
            @aLayerName = Array.new
            @aLayer = Array.new
            @aLayerIndex = Array.new
                                   
            layout = GridLayout.new(self)
            combogrid = GridLayout.new(self)
            setLayout(layout)
            
            combo_layer = ComboBox.new(self)
            combo_layer.minimumSize = QSize.new(20, 20)
            label_combo_layer = QLabel.new(self)
            label_combo_layer.text = "Layer to check"
            
            combo_layer_sep1 = ComboBox.new(self)
            combo_layer_sep1.minimumSize = QSize.new(20, 20)
            label_combo_layer_sep1 = QLabel.new(self)
            label_combo_layer_sep1.text = "Separation Check Layer1"
            
            combo_layer_sep2 = ComboBox.new(self)
            combo_layer_sep2.minimumSize = QSize.new(20, 20)
            label_combo_layer_sep2 = QLabel.new(self)
            label_combo_layer_sep2.text = "Separation Check Layer2"
            
            label_separation_check = QLabel.new(self)
            label_separation_check.text = "Separation in µm"
            spinbox_separation_check = QDoubleSpinBox.new
            spinbox_separation_check.minimumSize = QSize.new(20, 20)
            spinbox_separation_check.setDecimals(3)
            spinbox_separation_check.maximum=(1000)
            spinbox_separation_check.setMinimum(0.0001)
            spinbox_separation_check.value = 0 
            spinbox_separation_check.suffix=(" µm") 
            spinbox_separation_check.setSingleStep(0.01)
            
            label_space_check = QLabel.new(self)
            label_space_check.text = "Space in µm"
            spinbox_space_check = QDoubleSpinBox.new
            spinbox_space_check.minimumSize = QSize.new(20, 20)
            spinbox_space_check.setDecimals(3)
            spinbox_space_check.maximum=(1000)
            spinbox_space_check.setMinimum(0.0001)
            spinbox_space_check.value = 0 
            spinbox_space_check.suffix=(" µm")
            spinbox_space_check.setSingleStep(0.01) 
            
            label_width_check = QLabel.new(self)
            label_width_check.text = "width in µm"
            spinbox_width_check = QDoubleSpinBox.new
            spinbox_width_check.minimumSize = QSize.new(20, 20)
            spinbox_width_check.setDecimals(3)
            spinbox_width_check.maximum=(1000)
            spinbox_width_check.setMinimum(0.0001)
            spinbox_width_check.value = 0 
            spinbox_width_check.suffix=(" µm") 
            spinbox_width_check.setSingleStep(0.01)
            ###########

            #########
                        
            @textInput = TextEdit.new(self)
            @textInput.minimumSize = QSize.new(40, 200)
            
            @progress = ProgressBar.new(self)
            @progress.setRange(0,100)
            @progress.minimumSize = QSize.new(40, 20)
            @progress.setVisible(true)
            @progress.setTextVisible(false)
            @progress.value = 0
            
            placeholder = QLabel.new(self)
            placeholder.minimumSize = QSize.new(450,800)
            placeholder.text= " "
            
            combogrid.addWidget(label_combo_layer, 1, 0, 1, 1)
            combogrid.addWidget(combo_layer, 2, 0, 1, 1)
            combogrid.addWidget(label_width_check, 3, 0, 1, 1)
            combogrid.addWidget(spinbox_width_check, 4, 0, 1, 1)
            combogrid.addWidget(label_space_check, 5, 0, 1, 1)
            combogrid.addWidget(spinbox_space_check, 6, 0, 1, 1)
            combogrid.addWidget(@textInput, 8, 0, 1, 2)
            layout.addWidget(placeholder, 1, 1, 6, 1)
            
            combogrid.addWidget(label_combo_layer_sep1, 1, 1, 1, 1)
            combogrid.addWidget(combo_layer_sep1, 2, 1, 1, 1)
            combogrid.addWidget(label_combo_layer_sep2, 3, 1, 1, 1)
            combogrid.addWidget(combo_layer_sep2, 4, 1, 1, 1)
            combogrid.addWidget(label_separation_check, 5, 1, 1, 1)
            combogrid.addWidget(spinbox_separation_check, 6, 1, 1, 1)
                     
            layout.addLayout(combogrid, 1, 0, 6, 1)
            b3 = QPushButton.new(self)
            b3.text = "Start Width/Space Check"
            b3.minimumSize = QSize.new(20, 50)
            b3.clicked do
                space_violation = Array.new
                width_violation = Array.new
                calculation_settings_width_space(combo_layer.currentText, spinbox_space_check.value, spinbox_width_check.value)     
            end
            combogrid.addWidget(b3, 9, 0, 1, 1)
            
            b4 = QPushButton.new(self)
            b4.text = "Start Separation Check"
            b4.minimumSize = QSize.new(20, 50)
            b4.clicked do
                calculation_settings_separation(combo_layer_sep1.currentText,combo_layer_sep2.currentText, spinbox_separation_check.value)
            end
            combogrid.addWidget(b4, 9, 1, 1, 1)
             
            layout.addWidget(@progress, 12, 0, 1, 1)
            reload(@aLayerName, @aLayer, @aLayerIndex)
            @aLayer.each do | name|
                combo_layer.addItem(name)
                combo_layer_sep1.addItem(name)
                combo_layer_sep2.addItem(name)
            end
        end           
###############################################################
# #  perpare the calculation and store the results   
############################################################### toPlainText         
        def calculation_settings_width_space(layer, space_check_d, width_check_d)   
            time_start = Time.now
            space_violation = Array.new
            width_violation = Array.new
            space_width_check(layer, space_check_d, width_check_d, space_violation, width_violation) 
            
            width_violation_count = width_violation.length
            space_violation_count = space_violation.length
            
            data_path_width = @file_path + @title + "_" + (layer.split("/"))[0]+ "_" + (layer.split("/"))[1] + "_"  + "WidthViolations.csv"
            data_path_space = @file_path + @title + "_" + (layer.split("/"))[0]+ "_" + (layer.split("/"))[1]+ "_"  + "SpaceViolations.csv"
            
            report = "Width violations: \n " + width_violation_count.to_s + " EdgePairs smaller than " +  width_check_d.to_s + " µm "    
            report = report + "Layer: " + layer.to_s 
            report = report +  "\n \n Visible in Layer610,  Add other Layer Entries \n \n Calculation time: " +  (Time.now - time_start).to_s 
            report = report +  "\n \n data saved under " + data_path_width          
            
            data_to_file(width_violation,  report, data_path_width)
            
            report2 = "Space violations: \n " + space_violation_count.to_s + " EdgePairs smaller than " +  space_check_d.to_s + " µm "    
            report2 = report2 + "Layer: " + layer.to_s 
            report2 = report2 +  "\n \n Visible in Layer600,  Add other Layer Entries \n \n Calculation time: " +  (Time.now - time_start).to_s 
            report2 = report2 +  "\n \n data saved under " + data_path_space      
            
            data_to_file(space_violation,  report2, data_path_space) 
            @textInput.setPlainText(report+"\n\n" + report2)
            @textInput.repaint  
        end     
###############################################################
# #  perpare the calculation and store the results   
############################################################### toPlainText         
        def calculation_settings_separation(layer1, layer2, separation_check_d)   
            time_start = Time.now
            separation_violation = Array.new

            separation_check(layer1, layer2, separation_check_d, separation_violation) 
            
            separation_violation_count = separation_violation.length
            
            layer_name = (layer1.split("/"))[0]+ "_" + (layer1.split("/"))[1] + (layer2.split("/"))[0]+ "_" + (layer2.split("/"))[1]  
            data_path_separation = @file_path + @title + "_" +  layer_name + "_"  + "SeparationViolations.csv"
            
            report = "Separation violations: \n " + separation_violation_count.to_s + " EdgePairs smaller than " +  separation_check_d.to_s + " µm "    
            report = report + "Layer: " + layer1.to_s + " and " + layer2.to_s
            report = report +  "\n \n Visible in Layer620,  Add other Layer Entries \n \n Calculation time: " +  (Time.now - time_start).to_s 
            report = report +  "\n \n data saved under " + data_path_separation          
            
            data_to_file(separation_violation,  report, data_path_separation)

            @textInput.setPlainText(report)
            @textInput.repaint  
        end     
###############################################################
# # store the data in a file
###############################################################            
        def data_to_file(violation, report,data_path)
            dbu = @mw.current_view.active_cellview.layout.dbu
            if !@file_path == nil  then raise "No File path" end
            File.open(data_path, "a") do |file|      
                file.puts( "\n \n" + Time.now.to_s + "\n \n" + report + "\n \n")
                violation.each do |point|
                value = (point.x*dbu).to_s + ";"+  (point.y*dbu).to_s
                    file.puts(value)
                end
            end   
        end         
###############################################################
###############################################################                 
        def space_width_check(layer, space_d, width_d, space_violation, width_violation)
            dbu = @mw.current_view.active_cellview.layout.dbu
            cv = @mw.current_view.active_cellview
            
            layer_region = RBA::Region::new(@topcell.begin_shapes_rec(source_to_index(layer,@aLayer)))
            space_violation_edges = layer_region.space_check( space_d/dbu, false,nil, 70, nil, nil)
            width_violation_edges = layer_region.width_check( width_d/dbu, false, nil, 70, nil, nil)
            layer_region._destroy
            
            space_violation_edges.each do |edge_pair|
                space_violation.push(edge_pair.polygon(0).bbox.center)
            end    
            
            width_violation_edges.each do |edge_pair|
                width_violation.push(edge_pair.polygon(0).bbox.center)
            end    
            
            space_violation_layer = cv.layout.layer(RBA::LayerInfo::new(600,0))
            @topcell.layout.clear_layer(space_violation_layer)
            @topcell.shapes(space_violation_layer).insert(space_violation_edges.polygons)
            
            width_violation_layer = cv.layout.layer(RBA::LayerInfo::new(610,0))
            @topcell.layout.clear_layer(width_violation_layer)
            @topcell.shapes(width_violation_layer).insert(width_violation_edges.polygons)
                   
        end
###############################################################
###############################################################            
        def separation_check(layer1, layer2, separation_check_d, separation_violation)  
            dbu = @mw.current_view.active_cellview.layout.dbu
            cv = @mw.current_view.active_cellview        
            
            layer1_region = RBA::Region::new(@topcell.begin_shapes_rec(source_to_index(layer1,@aLayer)))   
            layer2_region = RBA::Region::new(@topcell.begin_shapes_rec(source_to_index(layer2,@aLayer)))       
            separation_violation_edges = layer1_region.separation_check( layer2_region, separation_check_d/dbu, false,nil, 40, nil, nil)
            #(const Region other, unsigned int d, bool whole_edges, variant metrics, variant ignore_angle, variant min_projection, variant max_projection)
            separation_violation_edges.each do |edge_pair|
                separation_violation.push(edge_pair.polygon(0).bbox.center)
            end
            
            width_violation_layer = cv.layout.layer(RBA::LayerInfo::new(620,0))
            @topcell.layout.clear_layer(width_violation_layer)
            @topcell.shapes(width_violation_layer).insert(separation_violation_edges.polygons)
            
            layer1_region._destroy
            layer2_region._destroy    
                    
        end
###############################################################
###############################################################                  
    end
###############################################################
###############################################################  
###############################################################
############################################################### 
  # Instantiate the dialog and make it visible initially.
  # Passing the $main_window will make it stay on top of the main window.
#  $dialog &amp;&amp; $dialog.destroy
    


end


class AreaCalEnvironment
    include AREAMODULE
	def initialize

		
		app = RBA::Application.instance
		mw = app.main_window

		@action = RBA::Action.new
		@action.title = "Chip Calculations"
		@action.on_triggered do
			view = RBA::Application.instance.main_window.current_view
			if !view
				raise "No view open for running the script on"
			end
			@dialog = AreaCal.new(Application::instance.main_window)
			@dialog.show
			# $dialog && $dialog.destroy
		end

		menu = mw.menu
		menu.insert_separator("tools_menu.end", "techfile_script_group")
		if !menu.is_menu?("tools_menu.techfile_submenu.end")
			menu.insert_menu("tools_menu.end", "techfile_submenu", "TechFile")
		end
		
		menu.insert_separator("tools_menu.techfile_submenu.end", "chip_cal_script_group")
		
		menu.insert_item("tools_menu.techfile_submenu.end", "chipcal_script_load", @action)
	end
end

$areacal_processing_environment = AreaCalEnvironment.new